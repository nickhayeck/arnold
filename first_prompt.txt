You are Codex working in an existing repo for “Arnold: Achieve Total Recall”, a lightweight Anki-like web study tool.

High-level intent
- A CLI command `arnold deck1.json deck2.json ...` starts a local web app (Flask) and opens a study UI in the browser.
- Keep the stack minimal: Python-first, Flask + Jinja2 templates, Typer for CLI, pytest for tests, htmx via CDN (no npm/build).
- Prefer stdlib for everything else (json, pathlib, datetime, sqlite3 if we choose it later).
- The project is already initialized and packages were added (at least: flask, typer, pytest). You may add more packages only if clearly justified; keep the door open but default to not adding anything.

Your first tasks (in this order)
1) Create AGENTS.md
2) Create PLAN.md
3) Implement an MVP that is demonstrably usable end-to-end

Deliverables
A) AGENTS.md
- Purpose: onboarding + “how to work in this repo” for AI agents and humans.
- Include:
  - How to run the app locally (CLI examples)
  - How to run tests (pytest)
  - Repo structure overview (key modules)
  - Coding conventions (stdlib-first, small functions, type hints where reasonable, no heavy frameworks)
  - Guardrails: minimal dependencies, deterministic behavior for tests, no network calls in tests, no build tooling for frontend

B) PLAN.md
- A concise engineering plan that captures decisions and “why”.
- Must include:
  - MVP scope (what is in/out)
  - Data model and persistence approach (see below)
  - CLI interface (flags, behavior)
  - Web routes + UI flow (htmx interactions)
  - Testing strategy
  - Follow-on milestones (import/export, tags, stats UI, scheduler improvements, SQLite option, etc.)
- Keep it realistic and incremental: MVP first, then extensions.

C) MVP implementation
Required user-facing capabilities
1. CLI
- `arnold <deck.json> [<deck2.json> ...]` starts the server and prints the URL.
- Flags (implement these now):
  - `--state-file PATH` default `arnold_state.json`
  - `--host TEXT` default `127.0.0.1`
  - `--port INT` default `8000` (or choose another sensible default)
  - `--no-browser` default open browser, but this disables that.
  - `--validate-only` (validate deck files and exit 0/1 with helpful messages)
  - `--debug` (Flask debug mode)
- Use Typer for CLI. Ensure `arnold --help` looks clean.

2. Deck format (JSON)
- Keep it simple and documented in PLAN.md (and optionally in README later).
- For MVP, support a JSON array of cards OR an object containing cards—choose ONE canonical format and optionally accept the other if trivial.
- Each card minimally has:
  - `id` (string or int; if absent, generate stable IDs from content+deck filename)
  - `front` (string)
  - `back` (string)
- Optional fields you may support if easy (not required for MVP): `tags` (list[str]), `deck` name override.
- Validation should catch:
  - invalid JSON
  - missing required fields
  - duplicate IDs within a deck
  - non-string front/back

3. Persistence & scheduling (MVP constraints)
- Keep dependencies minimal; default to JSON state file in `state-file`, not a DB.
- Do NOT require mutating the original deck JSON files for progress.
- Maintain an app “state” file, e.g. `state.json`, keyed by a stable card identifier (include deck identity).
- Minimal scheduling requirement:
  - Track per-card: `due` timestamp, `interval_days` (or seconds), `ease_factor`, `repetitions` (or similar)
  - Implement a basic SM-2-like algorithm or a simplified schedule:
    - Provide four ratings: Again / Hard / Good / Easy
    - Update due date deterministically based on rating
  - Default behavior: show due cards first; if none due, show new cards (cards without state).
  - Provide a “reset progress” mechanism later; for MVP, it can be a dev-only CLI option or not included.
- Ensure state file writes are atomic-ish (write temp then replace) to avoid corruption.

4. Web UI (Flask + Jinja2 + htmx via CDN)
- Must be functional and minimal, no SPA framework.
- Pages / routes:
  - `GET /` study page showing the next card “front”.
  - “Show answer” action reveals back (can be htmx or simple POST/GET).
  - After reveal, user can click Again/Hard/Good/Easy; this submits rating, updates scheduling state, and loads the next card.
  - A small status line: deck count loaded, due/new counts (approx is fine).
  - A “no cards available” state when everything is ahead of due; show next due time or message.
- Use htmx:
  - Load/replace a card fragment without full page reload where reasonable.
  - Keep it progressive: the app should still work without JS if possible, but htmx may be required for best UX (acceptable for MVP).
- Display latex via MathJAX or something like that. Document how this is added to the json and how its rendered in PLAN.
- Include minimal styling via CDN (optional): Pico.css or none; prioritize function.

5. Code structure (suggested; adapt to repo)
- Keep modules small and testable:
  - `arnold/cli.py` (Typer app)
  - `arnold/web.py` or `arnold/app.py` (Flask app factory + routes)
  - `arnold/decks.py` (loading/validation/id generation)
  - `arnold/state.py` (state read/write, atomic save)
  - `arnold/scheduler.py` (SM-2-ish updates, selecting next card)
  - `arnold/models.py` (dataclasses / typed dicts)
  - `arnold/templates/` (Jinja templates)
- Prefer an app factory pattern: `create_app(...)` so tests can instantiate without running a server.

6. Tests (pytest)
- Add tests that give confidence without being brittle:
  - Deck validation (good/bad JSON, missing fields, duplicate IDs)
  - State read/write (atomic save behavior; can simulate via temp dir)
  - Scheduler update logic: rating -> updated due/interval/ease, deterministic with frozen “now” (inject clock)
  - Next-card selection logic: due prioritized over new
- Avoid browser-based tests for MVP. Unit tests only.

Non-goals for MVP (explicitly out of scope; document in PLAN)
- Multi-user auth, sync, mobile apps
- Anki feature parity (media, cloze deletion, add-ons)
- Deck editing UI (you can add a minimal “view loaded decks” later)

Operational notes / acceptance criteria
- `arnold --validate deck.json` returns non-zero and prints a clear reason on failure.
- `arnold deck.json` launches the server, opens the browser by default (unless `--no-open`).
- A user can study at least a few cards and see progress persist across restarts (unless `--readonly`).
- `pytest` passes.

Implementation guidance
- Favor deterministic code: inject a `now()` function into scheduler/state to make tests stable.
- When generating stable IDs, consider: `sha1(deck_path + front + back)` truncated, stored as string. Ensure duplicates are still detectable if content repeats.
- Ensure that “deck identity” is stable: use absolute path or resolved path as part of the key.
- Keep error messages actionable: show file path, offending card index, and field name where possible.

Final step
- After implementing, briefly summarize in the PR-style notes (in PLAN.md or as comments) what’s done and what’s next.

Start now by creating AGENTS.md and PLAN.md, then implement the MVP with tests.

